# Лаба № 3 по системному программированию

## Общее
Написать программы с использованием примитивов синхронизации согласно варианту.

**Для успешной компиляции в CMakeLists.txt указать следующие строки.**

***find_package(Threads REQUIRED)***

***link_libraries(Threads::Threads)***

**Помните**, что функцию *sleep()* и ее вариации нельзя использовать для
синхронизации.

### Общее условие: 
В файле create_matrix.py генерируются матрицы 10х10 для лабораторной работы.

Программа должна прочитать данные из файла(-ов), обработать данные последовательно и
параллельно и вывести результаты и время обработки. Если результат для последовательного
и параллельного случая не совпадает – обосновать причину расхождения.
Файлы содержат данные в бинарном формате – т.е. их необходимо читать/записывать
вызовами *read() и write()* без всякого парсинга и обработки. 

Предполагается, что вы умеете
определять размер файла и заранее подготавливать буфер соответствующего размера.



## Задание.
### Необходимо:

**Задание 1.**
Написать программу, выполняющую умножение матриц. Преподавателем
выдается 2 файла – 2 большие матрицы из чисел типа double. Матрицы гарантированно
являются квадратными – размер матрицы можно (и нужно) вычислить из размера файла.
Демонстрацию корректности работы алгоритма проводить для матриц размера (10х10)
с выводом результата на экран. Время работы замерять для выданных преподавателем матриц.
Данную задачу решить без использования отдельных примитивов синхронизации.

**Задание 2.** 
Напишите шаблон класса потокобезопасной очереди
сообщений *threadsafe_queue<T>*. 

**Примитивы синхронизации** – мьютекс и условная
переменная. Полезно вспомнить про блокировку с двойной проверкой.

### Примерный интерфейс:
```
template <typename T>
class mt_queue{
public:
 mt_queue(size_t max_size);
 mt_queue(const mt_queue&) = delete;//no queue copy
 mt_queue(mt_queue&&) = delete; //no queue move
 ~mt_queue();
 void enqueue(const T& v); //shall block if full
 T dequeue(); //shall block if empty
 bool full() const;
 bool empty() const;
 std::optional<T> try_dequeue();
 bool try_enqueue(const T& v);
};
```

Продемонстрировать работу с M потоками-писателями и N потоками-обработчиками.

Способ демонстрации – на усмотрение студента. 
Самый простой способ – писатели пишут в
очередь числа, читатели распечатывают числа из очереди (при этом порядок распечатанных
элементов может отличаться от исходного, но сама очередь может работать корректно – если
такое наблюдается, обосновать).

Помните, что необходимо уведомлять потоки-читатели о том, что новых данных больше
не будет. Данная задача может решаться и вне класса threadsafe_queue<T> (отдельная
переменная, сигнал, сообщение со специальным значением и пр.). Итоговый способ
реализации также остается на усмотрение студента


### Данная лабораторная работа выполнялась ***только на сложном уровне***.
### При этом задание 1 реализовано в файле [lab.cpp](https://github.com/d7anSeR/lab2sys_prog/blob/main/main.cpp), а задание 2 - [queue.cpp](https://github.com/d7anSeR/lab3sys_prog/blob/main/queue.cpp).

## Полное задание на лабу можно найти [здесь](https://github.com/itsecd/system-programming/blob/main/Labs/Лабораторная%20работа%203.pdf)
